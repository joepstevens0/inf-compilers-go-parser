Grammar

    0 $accept: start $end

    1 start: prog

    2 prog: stm SEMICOLON prog
    3     | stm
    4     | blockstm SEMICOLON prog
    5     | blockstm

    6 stm: VAR IDENTIFIER INT ASSIGN exp
    7    | VAR IDENTIFIER INT
    8    | VAR IDENTIFIER BOOL ASSIGN exp
    9    | VAR IDENTIFIER BOOL
   10    | VAR IDENTIFIER RUNE ASSIGN exp
   11    | VAR IDENTIFIER RUNE
   12    | VAR IDENTIFIER STRING ASSIGN exp
   13    | VAR IDENTIFIER STRING
   14    | VAR IDENTIFIER ASSIGN exp
   15    | FUNC IDENTIFIER signature blockstm
   16    | PACKAGE IDENTIFIER
   17    | assignment
   18    | IDENTIFIER LPAREN arguments RPAREN
   19    | RETURN exp
   20    | RETURN
   21    | IDENTIFIER INC
   22    | IDENTIFIER DEC
   23    | ifstm
   24    | FOR exp blockstm
   25    | FOR stm SEMICOLON exp SEMICOLON stm blockstm
   26    | %empty
   27    | error

   28 ifstm: IF exp blockstm
   29      | IF stm SEMICOLON exp blockstm
   30      | IF exp blockstm ELSE ifstm
   31      | IF exp blockstm ELSE blockstm
   32      | IF stm SEMICOLON exp blockstm ELSE ifstm
   33      | IF stm SEMICOLON exp blockstm ELSE blockstm

   34 blockstm: LBRACE prog RBRACE

   35 realtype: INT
   36         | BOOL
   37         | RUNE
   38         | STRING

   39 type: realtype
   40     | %empty

   41 exp: rel_exp
   42    | exp binary_op rel_exp

   43 rel_exp: add_exp
   44        | rel_exp rel_op add_exp

   45 add_exp: mul_exp
   46        | add_exp add_op mul_exp

   47 mul_exp: index_exp
   48        | mul_exp mul_op operand

   49 index_exp: operand
   50          | index_exp LBRACK exp RBRACK

   51 operand: IDENTIFIER
   52        | IDENTIFIER LPAREN arguments RPAREN
   53        | LPAREN exp RPAREN
   54        | BOOLLITERAL
   55        | INTLITERAL
   56        | RUNELITERAL
   57        | STRINGLITERAL
   58        | unary_op operand

   59 binary_op: AND
   60          | OR

   61 add_op: PLUS
   62       | MIN

   63 mul_op: MUL
   64       | DIV

   65 rel_op: GT
   66       | GE
   67       | LT
   68       | LE
   69       | EQ
   70       | NE

   71 unary_op: PLUS
   72         | MIN
   73         | NOT

   74 signature: LPAREN parameters RPAREN type

   75 parameters: parameter COMMA parameters
   76           | parameter
   77           | %empty

   78 parameter: IDENTIFIER realtype

   79 arguments: exp COMMA arguments
   80          | exp
   81          | %empty

   82 assignment: IDENTIFIER ASSIGN exp
   83           | IDENTIFIER PLUSASSIGN exp
   84           | IDENTIFIER MINASSIGN exp
   85           | IDENTIFIER MULASSIGN exp
   86           | IDENTIFIER DIVASSIGN exp


Terminals, with rules where they appear

    $end (0) 0
    error (256) 27
    IDENTIFIER <string> (258) 6 7 8 9 10 11 12 13 14 15 16 18 21 22 51 52 78 82 83 84 85 86
    INTLITERAL <integer> (259) 55
    BOOLLITERAL <boolean> (260) 54
    RUNELITERAL <character> (261) 56
    STRINGLITERAL <string> (262) 57
    SEMICOLON (263) 2 4 25 29 32 33
    COMMA (264) 75 79
    INT (265) 6 7 35
    BOOL (266) 8 9 36
    RUNE (267) 10 11 37
    STRING (268) 12 13 38
    PACKAGE (269) 16
    RETURN (270) 19 20
    VAR (271) 6 7 8 9 10 11 12 13 14
    IF (272) 28 29 30 31 32 33
    ELSE (273) 30 31 32 33
    FOR (274) 24 25
    LPAREN (275) 18 52 53 74
    RPAREN (276) 18 52 53 74
    LBRACE (277) 34
    RBRACE (278) 34
    LBRACK (279) 50
    RBRACK (280) 50
    PLUS (281) 61 71
    MIN (282) 62 72
    MUL (283) 63
    DIV (284) 64
    ASSIGN (285) 6 8 10 12 14 82
    PLUSASSIGN (286) 83
    MINASSIGN (287) 84
    MULASSIGN (288) 85
    DIVASSIGN (289) 86
    AND (290) 59
    OR (291) 60
    NOT (292) 73
    INC (293) 21
    DEC (294) 22
    GT (295) 65
    GE (296) 66
    LT (297) 67
    LE (298) 68
    EQ (299) 69
    NE (300) 70
    FUNC (301) 15
    UNARY (302)


Nonterminals, with rules where they appear

    $accept (48)
        on left: 0
    start <stm> (49)
        on left: 1
        on right: 0
    prog <stm> (50)
        on left: 2 3 4 5
        on right: 1 2 4 34
    stm <stm> (51)
        on left: 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
        on right: 2 3 25 29 32 33
    ifstm <ifstm> (52)
        on left: 28 29 30 31 32 33
        on right: 23 30 32
    blockstm <blockstm> (53)
        on left: 34
        on right: 4 5 15 24 25 28 29 30 31 32 33
    realtype <type> (54)
        on left: 35 36 37 38
        on right: 39 78
    type <type> (55)
        on left: 39 40
        on right: 74
    exp <exp> (56)
        on left: 41 42
        on right: 6 8 10 12 14 19 24 25 28 29 30 31 32 33 42 50 53 79 80 82 83 84 85 86
    rel_exp <exp> (57)
        on left: 43 44
        on right: 41 42 44
    add_exp <exp> (58)
        on left: 45 46
        on right: 43 44 46
    mul_exp <exp> (59)
        on left: 47 48
        on right: 45 46 48
    index_exp <exp> (60)
        on left: 49 50
        on right: 47 50
    operand <exp> (61)
        on left: 51 52 53 54 55 56 57 58
        on right: 48 49 58
    binary_op <op> (62)
        on left: 59 60
        on right: 42
    add_op <op> (63)
        on left: 61 62
        on right: 46
    mul_op <op> (64)
        on left: 63 64
        on right: 48
    rel_op <op> (65)
        on left: 65 66 67 68 69 70
        on right: 44
    unary_op <op> (66)
        on left: 71 72 73
        on right: 58
    signature <signature> (67)
        on left: 74
        on right: 15
    parameters <parameters> (68)
        on left: 75 76 77
        on right: 74 75
    parameter <parameter> (69)
        on left: 78
        on right: 75 76
    arguments <arguments> (70)
        on left: 79 80 81
        on right: 18 52 79
    assignment <stm> (71)
        on left: 82 83 84 85 86
        on right: 17


State 0

    0 $accept: • start $end

    error       shift, and go to state 1
    IDENTIFIER  shift, and go to state 2
    PACKAGE     shift, and go to state 3
    RETURN      shift, and go to state 4
    VAR         shift, and go to state 5
    IF          shift, and go to state 6
    FOR         shift, and go to state 7
    LBRACE      shift, and go to state 8
    FUNC        shift, and go to state 9

    $end       reduce using rule 26 (stm)
    SEMICOLON  reduce using rule 26 (stm)

    start       go to state 10
    prog        go to state 11
    stm         go to state 12
    ifstm       go to state 13
    blockstm    go to state 14
    assignment  go to state 15


State 1

   27 stm: error •

    $default  reduce using rule 27 (stm)


State 2

   18 stm: IDENTIFIER • LPAREN arguments RPAREN
   21    | IDENTIFIER • INC
   22    | IDENTIFIER • DEC
   82 assignment: IDENTIFIER • ASSIGN exp
   83           | IDENTIFIER • PLUSASSIGN exp
   84           | IDENTIFIER • MINASSIGN exp
   85           | IDENTIFIER • MULASSIGN exp
   86           | IDENTIFIER • DIVASSIGN exp

    LPAREN      shift, and go to state 16
    ASSIGN      shift, and go to state 17
    PLUSASSIGN  shift, and go to state 18
    MINASSIGN   shift, and go to state 19
    MULASSIGN   shift, and go to state 20
    DIVASSIGN   shift, and go to state 21
    INC         shift, and go to state 22
    DEC         shift, and go to state 23


State 3

   16 stm: PACKAGE • IDENTIFIER

    IDENTIFIER  shift, and go to state 24


State 4

   19 stm: RETURN • exp
   20    | RETURN •

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    $default  reduce using rule 20 (stm)

    exp        go to state 34
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 5

    6 stm: VAR • IDENTIFIER INT ASSIGN exp
    7    | VAR • IDENTIFIER INT
    8    | VAR • IDENTIFIER BOOL ASSIGN exp
    9    | VAR • IDENTIFIER BOOL
   10    | VAR • IDENTIFIER RUNE ASSIGN exp
   11    | VAR • IDENTIFIER RUNE
   12    | VAR • IDENTIFIER STRING ASSIGN exp
   13    | VAR • IDENTIFIER STRING
   14    | VAR • IDENTIFIER ASSIGN exp

    IDENTIFIER  shift, and go to state 41


State 6

   28 ifstm: IF • exp blockstm
   29      | IF • stm SEMICOLON exp blockstm
   30      | IF • exp blockstm ELSE ifstm
   31      | IF • exp blockstm ELSE blockstm
   32      | IF • stm SEMICOLON exp blockstm ELSE ifstm
   33      | IF • stm SEMICOLON exp blockstm ELSE blockstm

    error          shift, and go to state 1
    IDENTIFIER     shift, and go to state 42
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    PACKAGE        shift, and go to state 3
    RETURN         shift, and go to state 4
    VAR            shift, and go to state 5
    IF             shift, and go to state 6
    FOR            shift, and go to state 7
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33
    FUNC           shift, and go to state 9

    SEMICOLON  reduce using rule 26 (stm)

    stm         go to state 43
    ifstm       go to state 13
    exp         go to state 44
    rel_exp     go to state 35
    add_exp     go to state 36
    mul_exp     go to state 37
    index_exp   go to state 38
    operand     go to state 39
    unary_op    go to state 40
    assignment  go to state 15


State 7

   24 stm: FOR • exp blockstm
   25    | FOR • stm SEMICOLON exp SEMICOLON stm blockstm

    error          shift, and go to state 1
    IDENTIFIER     shift, and go to state 42
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    PACKAGE        shift, and go to state 3
    RETURN         shift, and go to state 4
    VAR            shift, and go to state 5
    IF             shift, and go to state 6
    FOR            shift, and go to state 7
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33
    FUNC           shift, and go to state 9

    SEMICOLON  reduce using rule 26 (stm)

    stm         go to state 45
    ifstm       go to state 13
    exp         go to state 46
    rel_exp     go to state 35
    add_exp     go to state 36
    mul_exp     go to state 37
    index_exp   go to state 38
    operand     go to state 39
    unary_op    go to state 40
    assignment  go to state 15


State 8

   34 blockstm: LBRACE • prog RBRACE

    error       shift, and go to state 1
    IDENTIFIER  shift, and go to state 2
    PACKAGE     shift, and go to state 3
    RETURN      shift, and go to state 4
    VAR         shift, and go to state 5
    IF          shift, and go to state 6
    FOR         shift, and go to state 7
    LBRACE      shift, and go to state 8
    FUNC        shift, and go to state 9

    SEMICOLON  reduce using rule 26 (stm)
    RBRACE     reduce using rule 26 (stm)

    prog        go to state 47
    stm         go to state 12
    ifstm       go to state 13
    blockstm    go to state 14
    assignment  go to state 15


State 9

   15 stm: FUNC • IDENTIFIER signature blockstm

    IDENTIFIER  shift, and go to state 48


State 10

    0 $accept: start • $end

    $end  shift, and go to state 49


State 11

    1 start: prog •

    $default  reduce using rule 1 (start)


State 12

    2 prog: stm • SEMICOLON prog
    3     | stm •

    SEMICOLON  shift, and go to state 50

    $default  reduce using rule 3 (prog)


State 13

   23 stm: ifstm •

    $default  reduce using rule 23 (stm)


State 14

    4 prog: blockstm • SEMICOLON prog
    5     | blockstm •

    SEMICOLON  shift, and go to state 51

    $default  reduce using rule 5 (prog)


State 15

   17 stm: assignment •

    $default  reduce using rule 17 (stm)


State 16

   18 stm: IDENTIFIER LPAREN • arguments RPAREN

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    $default  reduce using rule 81 (arguments)

    exp        go to state 52
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40
    arguments  go to state 53


State 17

   82 assignment: IDENTIFIER ASSIGN • exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 54
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 18

   83 assignment: IDENTIFIER PLUSASSIGN • exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 55
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 19

   84 assignment: IDENTIFIER MINASSIGN • exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 56
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 20

   85 assignment: IDENTIFIER MULASSIGN • exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 57
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 21

   86 assignment: IDENTIFIER DIVASSIGN • exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 58
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 22

   21 stm: IDENTIFIER INC •

    $default  reduce using rule 21 (stm)


State 23

   22 stm: IDENTIFIER DEC •

    $default  reduce using rule 22 (stm)


State 24

   16 stm: PACKAGE IDENTIFIER •

    $default  reduce using rule 16 (stm)


State 25

   51 operand: IDENTIFIER •
   52        | IDENTIFIER • LPAREN arguments RPAREN

    LPAREN  shift, and go to state 59

    $default  reduce using rule 51 (operand)


State 26

   55 operand: INTLITERAL •

    $default  reduce using rule 55 (operand)


State 27

   54 operand: BOOLLITERAL •

    $default  reduce using rule 54 (operand)


State 28

   56 operand: RUNELITERAL •

    $default  reduce using rule 56 (operand)


State 29

   57 operand: STRINGLITERAL •

    $default  reduce using rule 57 (operand)


State 30

   53 operand: LPAREN • exp RPAREN

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 60
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 31

   71 unary_op: PLUS •

    $default  reduce using rule 71 (unary_op)


State 32

   72 unary_op: MIN •

    $default  reduce using rule 72 (unary_op)


State 33

   73 unary_op: NOT •

    $default  reduce using rule 73 (unary_op)


State 34

   19 stm: RETURN exp •
   42 exp: exp • binary_op rel_exp

    AND  shift, and go to state 61
    OR   shift, and go to state 62

    $default  reduce using rule 19 (stm)

    binary_op  go to state 63


State 35

   41 exp: rel_exp •
   44 rel_exp: rel_exp • rel_op add_exp

    GT  shift, and go to state 64
    GE  shift, and go to state 65
    LT  shift, and go to state 66
    LE  shift, and go to state 67
    EQ  shift, and go to state 68
    NE  shift, and go to state 69

    $default  reduce using rule 41 (exp)

    rel_op  go to state 70


State 36

   43 rel_exp: add_exp •
   46 add_exp: add_exp • add_op mul_exp

    PLUS  shift, and go to state 71
    MIN   shift, and go to state 72

    $default  reduce using rule 43 (rel_exp)

    add_op  go to state 73


State 37

   45 add_exp: mul_exp •
   48 mul_exp: mul_exp • mul_op operand

    MUL  shift, and go to state 74
    DIV  shift, and go to state 75

    $default  reduce using rule 45 (add_exp)

    mul_op  go to state 76


State 38

   47 mul_exp: index_exp •
   50 index_exp: index_exp • LBRACK exp RBRACK

    LBRACK  shift, and go to state 77

    $default  reduce using rule 47 (mul_exp)


State 39

   49 index_exp: operand •

    $default  reduce using rule 49 (index_exp)


State 40

   58 operand: unary_op • operand

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    operand   go to state 78
    unary_op  go to state 40


State 41

    6 stm: VAR IDENTIFIER • INT ASSIGN exp
    7    | VAR IDENTIFIER • INT
    8    | VAR IDENTIFIER • BOOL ASSIGN exp
    9    | VAR IDENTIFIER • BOOL
   10    | VAR IDENTIFIER • RUNE ASSIGN exp
   11    | VAR IDENTIFIER • RUNE
   12    | VAR IDENTIFIER • STRING ASSIGN exp
   13    | VAR IDENTIFIER • STRING
   14    | VAR IDENTIFIER • ASSIGN exp

    INT     shift, and go to state 79
    BOOL    shift, and go to state 80
    RUNE    shift, and go to state 81
    STRING  shift, and go to state 82
    ASSIGN  shift, and go to state 83


State 42

   18 stm: IDENTIFIER • LPAREN arguments RPAREN
   21    | IDENTIFIER • INC
   22    | IDENTIFIER • DEC
   51 operand: IDENTIFIER •
   52        | IDENTIFIER • LPAREN arguments RPAREN
   82 assignment: IDENTIFIER • ASSIGN exp
   83           | IDENTIFIER • PLUSASSIGN exp
   84           | IDENTIFIER • MINASSIGN exp
   85           | IDENTIFIER • MULASSIGN exp
   86           | IDENTIFIER • DIVASSIGN exp

    LPAREN      shift, and go to state 84
    ASSIGN      shift, and go to state 17
    PLUSASSIGN  shift, and go to state 18
    MINASSIGN   shift, and go to state 19
    MULASSIGN   shift, and go to state 20
    DIVASSIGN   shift, and go to state 21
    INC         shift, and go to state 22
    DEC         shift, and go to state 23

    $default  reduce using rule 51 (operand)


State 43

   29 ifstm: IF stm • SEMICOLON exp blockstm
   32      | IF stm • SEMICOLON exp blockstm ELSE ifstm
   33      | IF stm • SEMICOLON exp blockstm ELSE blockstm

    SEMICOLON  shift, and go to state 85


State 44

   28 ifstm: IF exp • blockstm
   30      | IF exp • blockstm ELSE ifstm
   31      | IF exp • blockstm ELSE blockstm
   42 exp: exp • binary_op rel_exp

    LBRACE  shift, and go to state 8
    AND     shift, and go to state 61
    OR      shift, and go to state 62

    blockstm   go to state 86
    binary_op  go to state 63


State 45

   25 stm: FOR stm • SEMICOLON exp SEMICOLON stm blockstm

    SEMICOLON  shift, and go to state 87


State 46

   24 stm: FOR exp • blockstm
   42 exp: exp • binary_op rel_exp

    LBRACE  shift, and go to state 8
    AND     shift, and go to state 61
    OR      shift, and go to state 62

    blockstm   go to state 88
    binary_op  go to state 63


State 47

   34 blockstm: LBRACE prog • RBRACE

    RBRACE  shift, and go to state 89


State 48

   15 stm: FUNC IDENTIFIER • signature blockstm

    LPAREN  shift, and go to state 90

    signature  go to state 91


State 49

    0 $accept: start $end •

    $default  accept


State 50

    2 prog: stm SEMICOLON • prog

    error       shift, and go to state 1
    IDENTIFIER  shift, and go to state 2
    PACKAGE     shift, and go to state 3
    RETURN      shift, and go to state 4
    VAR         shift, and go to state 5
    IF          shift, and go to state 6
    FOR         shift, and go to state 7
    LBRACE      shift, and go to state 8
    FUNC        shift, and go to state 9

    $end       reduce using rule 26 (stm)
    SEMICOLON  reduce using rule 26 (stm)
    RBRACE     reduce using rule 26 (stm)

    prog        go to state 92
    stm         go to state 12
    ifstm       go to state 13
    blockstm    go to state 14
    assignment  go to state 15


State 51

    4 prog: blockstm SEMICOLON • prog

    error       shift, and go to state 1
    IDENTIFIER  shift, and go to state 2
    PACKAGE     shift, and go to state 3
    RETURN      shift, and go to state 4
    VAR         shift, and go to state 5
    IF          shift, and go to state 6
    FOR         shift, and go to state 7
    LBRACE      shift, and go to state 8
    FUNC        shift, and go to state 9

    $end       reduce using rule 26 (stm)
    SEMICOLON  reduce using rule 26 (stm)
    RBRACE     reduce using rule 26 (stm)

    prog        go to state 93
    stm         go to state 12
    ifstm       go to state 13
    blockstm    go to state 14
    assignment  go to state 15


State 52

   42 exp: exp • binary_op rel_exp
   79 arguments: exp • COMMA arguments
   80          | exp •

    COMMA  shift, and go to state 94
    AND    shift, and go to state 61
    OR     shift, and go to state 62

    $default  reduce using rule 80 (arguments)

    binary_op  go to state 63


State 53

   18 stm: IDENTIFIER LPAREN arguments • RPAREN

    RPAREN  shift, and go to state 95


State 54

   42 exp: exp • binary_op rel_exp
   82 assignment: IDENTIFIER ASSIGN exp •

    AND  shift, and go to state 61
    OR   shift, and go to state 62

    $default  reduce using rule 82 (assignment)

    binary_op  go to state 63


State 55

   42 exp: exp • binary_op rel_exp
   83 assignment: IDENTIFIER PLUSASSIGN exp •

    AND  shift, and go to state 61
    OR   shift, and go to state 62

    $default  reduce using rule 83 (assignment)

    binary_op  go to state 63


State 56

   42 exp: exp • binary_op rel_exp
   84 assignment: IDENTIFIER MINASSIGN exp •

    AND  shift, and go to state 61
    OR   shift, and go to state 62

    $default  reduce using rule 84 (assignment)

    binary_op  go to state 63


State 57

   42 exp: exp • binary_op rel_exp
   85 assignment: IDENTIFIER MULASSIGN exp •

    AND  shift, and go to state 61
    OR   shift, and go to state 62

    $default  reduce using rule 85 (assignment)

    binary_op  go to state 63


State 58

   42 exp: exp • binary_op rel_exp
   86 assignment: IDENTIFIER DIVASSIGN exp •

    AND  shift, and go to state 61
    OR   shift, and go to state 62

    $default  reduce using rule 86 (assignment)

    binary_op  go to state 63


State 59

   52 operand: IDENTIFIER LPAREN • arguments RPAREN

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    $default  reduce using rule 81 (arguments)

    exp        go to state 52
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40
    arguments  go to state 96


State 60

   42 exp: exp • binary_op rel_exp
   53 operand: LPAREN exp • RPAREN

    RPAREN  shift, and go to state 97
    AND     shift, and go to state 61
    OR      shift, and go to state 62

    binary_op  go to state 63


State 61

   59 binary_op: AND •

    $default  reduce using rule 59 (binary_op)


State 62

   60 binary_op: OR •

    $default  reduce using rule 60 (binary_op)


State 63

   42 exp: exp binary_op • rel_exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    rel_exp    go to state 98
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 64

   65 rel_op: GT •

    $default  reduce using rule 65 (rel_op)


State 65

   66 rel_op: GE •

    $default  reduce using rule 66 (rel_op)


State 66

   67 rel_op: LT •

    $default  reduce using rule 67 (rel_op)


State 67

   68 rel_op: LE •

    $default  reduce using rule 68 (rel_op)


State 68

   69 rel_op: EQ •

    $default  reduce using rule 69 (rel_op)


State 69

   70 rel_op: NE •

    $default  reduce using rule 70 (rel_op)


State 70

   44 rel_exp: rel_exp rel_op • add_exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    add_exp    go to state 99
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 71

   61 add_op: PLUS •

    $default  reduce using rule 61 (add_op)


State 72

   62 add_op: MIN •

    $default  reduce using rule 62 (add_op)


State 73

   46 add_exp: add_exp add_op • mul_exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    mul_exp    go to state 100
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 74

   63 mul_op: MUL •

    $default  reduce using rule 63 (mul_op)


State 75

   64 mul_op: DIV •

    $default  reduce using rule 64 (mul_op)


State 76

   48 mul_exp: mul_exp mul_op • operand

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    operand   go to state 101
    unary_op  go to state 40


State 77

   50 index_exp: index_exp LBRACK • exp RBRACK

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 102
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 78

   58 operand: unary_op operand •

    $default  reduce using rule 58 (operand)


State 79

    6 stm: VAR IDENTIFIER INT • ASSIGN exp
    7    | VAR IDENTIFIER INT •

    ASSIGN  shift, and go to state 103

    $default  reduce using rule 7 (stm)


State 80

    8 stm: VAR IDENTIFIER BOOL • ASSIGN exp
    9    | VAR IDENTIFIER BOOL •

    ASSIGN  shift, and go to state 104

    $default  reduce using rule 9 (stm)


State 81

   10 stm: VAR IDENTIFIER RUNE • ASSIGN exp
   11    | VAR IDENTIFIER RUNE •

    ASSIGN  shift, and go to state 105

    $default  reduce using rule 11 (stm)


State 82

   12 stm: VAR IDENTIFIER STRING • ASSIGN exp
   13    | VAR IDENTIFIER STRING •

    ASSIGN  shift, and go to state 106

    $default  reduce using rule 13 (stm)


State 83

   14 stm: VAR IDENTIFIER ASSIGN • exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 107
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 84

   18 stm: IDENTIFIER LPAREN • arguments RPAREN
   52 operand: IDENTIFIER LPAREN • arguments RPAREN

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    $default  reduce using rule 81 (arguments)

    exp        go to state 52
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40
    arguments  go to state 108


State 85

   29 ifstm: IF stm SEMICOLON • exp blockstm
   32      | IF stm SEMICOLON • exp blockstm ELSE ifstm
   33      | IF stm SEMICOLON • exp blockstm ELSE blockstm

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 109
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 86

   28 ifstm: IF exp blockstm •
   30      | IF exp blockstm • ELSE ifstm
   31      | IF exp blockstm • ELSE blockstm

    ELSE  shift, and go to state 110

    $default  reduce using rule 28 (ifstm)


State 87

   25 stm: FOR stm SEMICOLON • exp SEMICOLON stm blockstm

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 111
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 88

   24 stm: FOR exp blockstm •

    $default  reduce using rule 24 (stm)


State 89

   34 blockstm: LBRACE prog RBRACE •

    $default  reduce using rule 34 (blockstm)


State 90

   74 signature: LPAREN • parameters RPAREN type

    IDENTIFIER  shift, and go to state 112

    $default  reduce using rule 77 (parameters)

    parameters  go to state 113
    parameter   go to state 114


State 91

   15 stm: FUNC IDENTIFIER signature • blockstm

    LBRACE  shift, and go to state 8

    blockstm  go to state 115


State 92

    2 prog: stm SEMICOLON prog •

    $default  reduce using rule 2 (prog)


State 93

    4 prog: blockstm SEMICOLON prog •

    $default  reduce using rule 4 (prog)


State 94

   79 arguments: exp COMMA • arguments

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    $default  reduce using rule 81 (arguments)

    exp        go to state 52
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40
    arguments  go to state 116


State 95

   18 stm: IDENTIFIER LPAREN arguments RPAREN •

    $default  reduce using rule 18 (stm)


State 96

   52 operand: IDENTIFIER LPAREN arguments • RPAREN

    RPAREN  shift, and go to state 117


State 97

   53 operand: LPAREN exp RPAREN •

    $default  reduce using rule 53 (operand)


State 98

   42 exp: exp binary_op rel_exp •
   44 rel_exp: rel_exp • rel_op add_exp

    GT  shift, and go to state 64
    GE  shift, and go to state 65
    LT  shift, and go to state 66
    LE  shift, and go to state 67
    EQ  shift, and go to state 68
    NE  shift, and go to state 69

    $default  reduce using rule 42 (exp)

    rel_op  go to state 70


State 99

   44 rel_exp: rel_exp rel_op add_exp •
   46 add_exp: add_exp • add_op mul_exp

    PLUS  shift, and go to state 71
    MIN   shift, and go to state 72

    $default  reduce using rule 44 (rel_exp)

    add_op  go to state 73


State 100

   46 add_exp: add_exp add_op mul_exp •
   48 mul_exp: mul_exp • mul_op operand

    MUL  shift, and go to state 74
    DIV  shift, and go to state 75

    $default  reduce using rule 46 (add_exp)

    mul_op  go to state 76


State 101

   48 mul_exp: mul_exp mul_op operand •

    $default  reduce using rule 48 (mul_exp)


State 102

   42 exp: exp • binary_op rel_exp
   50 index_exp: index_exp LBRACK exp • RBRACK

    RBRACK  shift, and go to state 118
    AND     shift, and go to state 61
    OR      shift, and go to state 62

    binary_op  go to state 63


State 103

    6 stm: VAR IDENTIFIER INT ASSIGN • exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 119
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 104

    8 stm: VAR IDENTIFIER BOOL ASSIGN • exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 120
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 105

   10 stm: VAR IDENTIFIER RUNE ASSIGN • exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 121
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 106

   12 stm: VAR IDENTIFIER STRING ASSIGN • exp

    IDENTIFIER     shift, and go to state 25
    INTLITERAL     shift, and go to state 26
    BOOLLITERAL    shift, and go to state 27
    RUNELITERAL    shift, and go to state 28
    STRINGLITERAL  shift, and go to state 29
    LPAREN         shift, and go to state 30
    PLUS           shift, and go to state 31
    MIN            shift, and go to state 32
    NOT            shift, and go to state 33

    exp        go to state 122
    rel_exp    go to state 35
    add_exp    go to state 36
    mul_exp    go to state 37
    index_exp  go to state 38
    operand    go to state 39
    unary_op   go to state 40


State 107

   14 stm: VAR IDENTIFIER ASSIGN exp •
   42 exp: exp • binary_op rel_exp

    AND  shift, and go to state 61
    OR   shift, and go to state 62

    $default  reduce using rule 14 (stm)

    binary_op  go to state 63


State 108

   18 stm: IDENTIFIER LPAREN arguments • RPAREN
   52 operand: IDENTIFIER LPAREN arguments • RPAREN

    RPAREN  shift, and go to state 123


State 109

   29 ifstm: IF stm SEMICOLON exp • blockstm
   32      | IF stm SEMICOLON exp • blockstm ELSE ifstm
   33      | IF stm SEMICOLON exp • blockstm ELSE blockstm
   42 exp: exp • binary_op rel_exp

    LBRACE  shift, and go to state 8
    AND     shift, and go to state 61
    OR      shift, and go to state 62

    blockstm   go to state 124
    binary_op  go to state 63


State 110

   30 ifstm: IF exp blockstm ELSE • ifstm
   31      | IF exp blockstm ELSE • blockstm

    IF      shift, and go to state 6
    LBRACE  shift, and go to state 8

    ifstm     go to state 125
    blockstm  go to state 126


State 111

   25 stm: FOR stm SEMICOLON exp • SEMICOLON stm blockstm
   42 exp: exp • binary_op rel_exp

    SEMICOLON  shift, and go to state 127
    AND        shift, and go to state 61
    OR         shift, and go to state 62

    binary_op  go to state 63


State 112

   78 parameter: IDENTIFIER • realtype

    INT     shift, and go to state 128
    BOOL    shift, and go to state 129
    RUNE    shift, and go to state 130
    STRING  shift, and go to state 131

    realtype  go to state 132


State 113

   74 signature: LPAREN parameters • RPAREN type

    RPAREN  shift, and go to state 133


State 114

   75 parameters: parameter • COMMA parameters
   76           | parameter •

    COMMA  shift, and go to state 134

    $default  reduce using rule 76 (parameters)


State 115

   15 stm: FUNC IDENTIFIER signature blockstm •

    $default  reduce using rule 15 (stm)


State 116

   79 arguments: exp COMMA arguments •

    $default  reduce using rule 79 (arguments)


State 117

   52 operand: IDENTIFIER LPAREN arguments RPAREN •

    $default  reduce using rule 52 (operand)


State 118

   50 index_exp: index_exp LBRACK exp RBRACK •

    $default  reduce using rule 50 (index_exp)


State 119

    6 stm: VAR IDENTIFIER INT ASSIGN exp •
   42 exp: exp • binary_op rel_exp

    AND  shift, and go to state 61
    OR   shift, and go to state 62

    $default  reduce using rule 6 (stm)

    binary_op  go to state 63


State 120

    8 stm: VAR IDENTIFIER BOOL ASSIGN exp •
   42 exp: exp • binary_op rel_exp

    AND  shift, and go to state 61
    OR   shift, and go to state 62

    $default  reduce using rule 8 (stm)

    binary_op  go to state 63


State 121

   10 stm: VAR IDENTIFIER RUNE ASSIGN exp •
   42 exp: exp • binary_op rel_exp

    AND  shift, and go to state 61
    OR   shift, and go to state 62

    $default  reduce using rule 10 (stm)

    binary_op  go to state 63


State 122

   12 stm: VAR IDENTIFIER STRING ASSIGN exp •
   42 exp: exp • binary_op rel_exp

    AND  shift, and go to state 61
    OR   shift, and go to state 62

    $default  reduce using rule 12 (stm)

    binary_op  go to state 63


State 123

   18 stm: IDENTIFIER LPAREN arguments RPAREN •
   52 operand: IDENTIFIER LPAREN arguments RPAREN •

    SEMICOLON  reduce using rule 18 (stm)
    $default   reduce using rule 52 (operand)


State 124

   29 ifstm: IF stm SEMICOLON exp blockstm •
   32      | IF stm SEMICOLON exp blockstm • ELSE ifstm
   33      | IF stm SEMICOLON exp blockstm • ELSE blockstm

    ELSE  shift, and go to state 135

    $default  reduce using rule 29 (ifstm)


State 125

   30 ifstm: IF exp blockstm ELSE ifstm •

    $default  reduce using rule 30 (ifstm)


State 126

   31 ifstm: IF exp blockstm ELSE blockstm •

    $default  reduce using rule 31 (ifstm)


State 127

   25 stm: FOR stm SEMICOLON exp SEMICOLON • stm blockstm

    error       shift, and go to state 1
    IDENTIFIER  shift, and go to state 2
    PACKAGE     shift, and go to state 3
    RETURN      shift, and go to state 4
    VAR         shift, and go to state 5
    IF          shift, and go to state 6
    FOR         shift, and go to state 7
    FUNC        shift, and go to state 9

    LBRACE  reduce using rule 26 (stm)

    stm         go to state 136
    ifstm       go to state 13
    assignment  go to state 15


State 128

   35 realtype: INT •

    $default  reduce using rule 35 (realtype)


State 129

   36 realtype: BOOL •

    $default  reduce using rule 36 (realtype)


State 130

   37 realtype: RUNE •

    $default  reduce using rule 37 (realtype)


State 131

   38 realtype: STRING •

    $default  reduce using rule 38 (realtype)


State 132

   78 parameter: IDENTIFIER realtype •

    $default  reduce using rule 78 (parameter)


State 133

   74 signature: LPAREN parameters RPAREN • type

    INT     shift, and go to state 128
    BOOL    shift, and go to state 129
    RUNE    shift, and go to state 130
    STRING  shift, and go to state 131

    $default  reduce using rule 40 (type)

    realtype  go to state 137
    type      go to state 138


State 134

   75 parameters: parameter COMMA • parameters

    IDENTIFIER  shift, and go to state 112

    $default  reduce using rule 77 (parameters)

    parameters  go to state 139
    parameter   go to state 114


State 135

   32 ifstm: IF stm SEMICOLON exp blockstm ELSE • ifstm
   33      | IF stm SEMICOLON exp blockstm ELSE • blockstm

    IF      shift, and go to state 6
    LBRACE  shift, and go to state 8

    ifstm     go to state 140
    blockstm  go to state 141


State 136

   25 stm: FOR stm SEMICOLON exp SEMICOLON stm • blockstm

    LBRACE  shift, and go to state 8

    blockstm  go to state 142


State 137

   39 type: realtype •

    $default  reduce using rule 39 (type)


State 138

   74 signature: LPAREN parameters RPAREN type •

    $default  reduce using rule 74 (signature)


State 139

   75 parameters: parameter COMMA parameters •

    $default  reduce using rule 75 (parameters)


State 140

   32 ifstm: IF stm SEMICOLON exp blockstm ELSE ifstm •

    $default  reduce using rule 32 (ifstm)


State 141

   33 ifstm: IF stm SEMICOLON exp blockstm ELSE blockstm •

    $default  reduce using rule 33 (ifstm)


State 142

   25 stm: FOR stm SEMICOLON exp SEMICOLON stm blockstm •

    $default  reduce using rule 25 (stm)
